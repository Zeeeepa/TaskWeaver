import io
import os
import sys
import traceback
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from standalone_taskweaver.logging import TelemetryLogger
from standalone_taskweaver.module.tracing import Tracing, tracing_decorator
from standalone_taskweaver.session.session import SessionMetadata


@dataclass
class Artifact:
    """
    Artifact is used to store the artifact generated by the code execution.
    """

    file_name: str
    mime_type: str


@dataclass
class ExecutionResult:
    """
    ExecutionResult is used to store the result of the code execution.
    """

    is_success: bool
    stdout: str
    stderr: str
    artifact: List[Artifact]
    exception: Optional[Exception] = None


class CodeExecutor:
    """
    CodeExecutor is used to execute the code.
    """

    @tracing_decorator
    def __init__(
        self,
        session_metadata: SessionMetadata,
        logger: TelemetryLogger,
        tracing: Tracing,
    ) -> None:
        self.session_metadata = session_metadata
        self.logger = logger
        self.tracing = tracing
        self.execution_cwd = session_metadata.execution_cwd
        self.session_var: Dict[str, str] = {}
        self.globals: Dict[str, Any] = {}
        self.is_started = False

    def start(self) -> None:
        """Start the code executor."""
        if self.is_started:
            return
        self.is_started = True
        self.globals = {
            "__name__": "__main__",
            "__builtins__": __builtins__,
            "session_var": self.session_var,
        }

    def stop(self) -> None:
        """Stop the code executor."""
        self.is_started = False
        self.globals = {}

    def update_session_var(self, session_var: Dict[str, str]) -> None:
        """Update the session variables."""
        self.session_var.update(session_var)
        if "session_var" in self.globals:
            self.globals["session_var"] = self.session_var

    @tracing_decorator
    def execute_code(
        self,
        exec_id: str,
        code: str,
    ) -> ExecutionResult:
        """
        Execute the code.
        :param exec_id: The execution ID.
        :param code: The code to execute.
        :return: The execution result.
        """
        if not self.is_started:
            self.start()

        # save the current working directory
        old_cwd = os.getcwd()
        # change to the execution directory
        os.chdir(self.execution_cwd)

        # save the current stdout and stderr
        old_stdout = sys.stdout
        old_stderr = sys.stderr
        # create new stdout and stderr
        new_stdout = io.StringIO()
        new_stderr = io.StringIO()
        # redirect stdout and stderr
        sys.stdout = new_stdout
        sys.stderr = new_stderr

        # execute the code
        is_success = True
        exception = None
        try:
            exec(code, self.globals)
        except Exception as e:
            is_success = False
            exception = e
            traceback.print_exc()

        # get the stdout and stderr
        stdout = new_stdout.getvalue()
        stderr = new_stderr.getvalue()

        # restore stdout and stderr
        sys.stdout = old_stdout
        sys.stderr = old_stderr

        # restore the current working directory
        os.chdir(old_cwd)

        # get the artifacts
        artifacts = []
        for file_name in os.listdir(self.execution_cwd):
            if os.path.isfile(os.path.join(self.execution_cwd, file_name)):
                # TODO: detect the mime type
                artifacts.append(Artifact(file_name=file_name, mime_type="application/octet-stream"))

        # create the execution result
        result = ExecutionResult(
            is_success=is_success,
            stdout=stdout,
            stderr=stderr,
            artifact=artifacts,
            exception=exception,
        )

        return result

    def format_code_output(
        self,
        result: ExecutionResult,
        with_code: bool = True,
        use_local_uri: bool = True,
        code_mask: Optional[str] = None,
    ) -> str:
        """
        Format the code output.
        :param result: The execution result.
        :param with_code: Whether to include the code in the output.
        :param use_local_uri: Whether to use local URI for artifacts.
        :param code_mask: The code mask.
        :return: The formatted output.
        """
        output = ""
        if with_code:
            output += "```python\n"
            if code_mask is not None:
                output += code_mask
            output += "\n```\n\n"

        if result.is_success:
            if result.stdout:
                output += "**Output:**\n\n"
                output += result.stdout
                output += "\n\n"

            if len(result.artifact) > 0:
                output += "**Artifacts:**\n\n"
                for artifact in result.artifact:
                    if use_local_uri:
                        output += f"- {artifact.file_name}\n"
                    else:
                        output += f"- {os.path.join(self.execution_cwd, artifact.file_name)}\n"
                output += "\n"
        else:
            output += "**Error:**\n\n"
            output += result.stderr
            output += "\n\n"

        return output

